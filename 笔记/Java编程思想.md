# Java 编程思想


## 1 对象导论

### 1.1 抽象过程

一种面向对象程序设计方式：
1. 万物皆对象
2. 程序是对象的集合
3. 每个对象都有自己的由其他对象所构成的存储
4. 每个对象都拥有其类型。
5. 某一特定类型的所有对象都可以接收同样的消息

对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（他们给出了该对象的状态）和方法（它们产生行为），并且每一个对象都可以唯一地狱其他对象区分分开，具体来说，就是每一个对象在内存中都有一个唯一的地址。

### 1.2 每个对象都有一个接口

### 1.3 每个对象都提供服务

### 1.4 被隐藏的具体实现

    public 表示紧随其后的元素对任何人都是可用的。
    private 表示除类型创建者和类型的内部方法之外，任何人都不能访问的元素、
    protected 尽在于继承的类可以访问protected成员
    
### 1.5 复用具体实现

### 1.6 继承

#### 1.6.1 “是一个” 与 “像是一个”关系

### 1.7 伴随多态的可互换对象

### 1.8 单根继承结构

### 1.9 容器

#### 1.9.1 参数化类型

### 1.10 对象的创建和生命期

### 1.11 异常处理：处理错误

### 1.12 并发编程

### 1.13 Java 与 Internet

#### 1.13.1 Web 是什么

1. 客户/服务器计算技术
2. Web 就是一台巨型服务器

#### 1.13.2  客户端编程

1. 插件
2. 脚本语言
3. Java
4. 备选方案
5. .Net 和 C#
6.  Internet 与 Intranet

#### 1.13.3 服务器端编程

### 1.14 总结

## 2 一切皆对象

### 2.1 用引用操纵对象

### 2.2 必须由你创建所有对象

#### 2.2.1 存储到什么地方

1. 寄存器
2. 堆栈
3. 堆
4. 常量存储
5. 非RAM存储

#### 2.2.2 特例：基本类型

#### 2.2.3 Java 中的数组

### 2.3 永远不需要销毁对象

#### 2.3.1 作用域

#### 2.3.2 对象的作用域

### 2.4 创建新的数据类型：类

#### 2.4.1 字段和方法

### 2.5 方法、参数和返回值

#### 2.5.1 参数列表

### 2.6 构建一个 Java 程序

#### 2.6.1 名字可见性

#### 2.6.2 运行其他构件

#### 2.6.3 static 关键字

### 2.7 你的第一个 Java 程序

#### 2.7.1 编译和运行

### 2.8 注释和嵌入式文档

#### 2.8.1 注释文档

#### 2.8.2 语法

#### 2.8.3 嵌入式 HTML

#### 2.8.4 一些标签示例

1. @see
2. @link
3. @docRoot
4. @inheritDoc
5. @version
6. @author
7. @since
8. @param
9. @return
10. @throws
11. @deprecated

#### 2.8.5 文档示例

### 2.9 编码风格

### 2.10 总结

### 2.11 练习

## 3 操作符

### 3.1 更简单的打印语句

### 3.2 使用 Java 操作符

### 3.3 优先级

### 3.4 赋值

#### 3.4.1 方法调用中的别名问题

### 3.5 算术操作符

#### 3.5.1 一元加、减操作符

### 3.6 自动递增和递减

### 3.7 关系操作符

#### 3.7.1 测试对象的等价性

### 3.8 逻辑操作符

#### 3.8.1 短路

### 3.9 直接常量

#### 3.9.1 指数记数法

### 3.10 按位操作符

### 3.11 移位操作符
 
### 3.12 三元操作符 if-else

### 3.13 字符串操作符 + 和 +=

### 3.14 使用操作符时常犯的错误

### 3.15 类型转换操作符

#### 3.15.1 截尾和舎入

#### 3.15.2 提升

### 3.16 Java 没有 sizeof

### 3.17 操作符小结

### 3.18 总结

## 4 控制执行流程

### 4.1 true 和 false

### 4.2 if-else

### 4.3 迭代

#### 4.3.1 do-while

#### 4.3.2 for

#### 4.3.3 逗号操作符

### 4.4 Foreach 语法

### 4.5 return

### 4.6 break 和 continue

### 4.7 臭名昭著的 goto

### 4.8 switch

### 4.9 总结

## 5 初始化与清理

### 5.1 用构造器确保初始化

### 5.2 方法重载

#### 5.2.1 区分重载方法

每个重载的方法都必须有一个独一无二的参数类型列表

#### 5.2.2 涉及基本类型的重载

#### 5.2.3 以返回值区分重载方法

### 5.3 默认构造器

### 5.4 this 关键字

#### 5.4.1 在构造器中调用构造器

#### 5.4.2 static 的含义

### 5.5 清理：终结处理和垃圾回收

#### 5.5.1 finalize() 的用途何在

#### 5.5.2 你必须实施清理

#### 5.5.3 终结条件

#### 5.5.4 垃圾回收器如何工作

### 5.6 成员初始化

#### 5.6.1 指定初始化

### 5.7 构造器初始化

#### 5.7.1 初始化顺序

#### 5.7.2 静态数据的初始化

1. 即使没有显式地使用 static 关键字，构造器实际上也是静态方法。
2. 然后载入 class 文件
3. 当用 new 创建对象的时候，首先讲在堆上为对象分配足够的存储空间
4. 这块存储空间会被清零，将所有基本类型数据都设置为默认值
5. 执行所有出现于字段定义处的初始化动作
6. 执行其构造器

#### 5.7.3 显式的静态初始化

#### 5.7.4 非静态实例初始化

### 5.8 数组初始化

#### 5.8.1 可变参数列表

### 5.9 枚举类型

### 5.10 总结

## 6 访问权限控制

### 6.1 包：库单元

#### 6.1.1 代码组织

#### 6.1.2 创建独一无二的包名

#### 6.1.3 定制工具库

#### 6.1.4 用 import 改变行为

#### 6.1.5 对使用包的忠告

### 6.2 Java 访问权限修饰词

#### 6.2.1 包访问权限

#### 6.2.2 pubic：接口访问权限

#### 6.2.3 private：你无法访问

#### 6.2.4 protected：继承访问权限

### 6.3 接口和实现

### 6.4 类的访问权限

### 6.5 总结

## 7 复用类

### 7.1 组合语法

### 7.2 继承语法

#### 7.2.1 初始化基类

### 7.3 代理

### 7.4 结合使用组合和继承

#### 7.4.1 确保正确清理

#### 7.4.2 名称屏蔽

### 7.5 在组合与继承之间选择

### 7.6 protected 关键字

### 7.7 向上转型

#### 7.7.1 为什么称为向上转型

#### 7.7.2 再论组合与继承

### 7.8 final 关键字

#### 7.8.1 final 数据

#### 7.8.2 final 方法

#### 7.8.3 final 类

#### 7.8.4 有关 final 的忠告

### 7.9 初始化及类的加载

#### 7.9.1 继承与初始化

### 7.10 总结

## 8  多态

### 8.1 再论向上转型

#### 8.1.1 忘记对象类型

### 8.2 转机

#### 8.2.1 方法调用绑定

Java 中除了 static 方法和 final 方法 (private 方法属于final方法)之外，其他所有的方法都是后期绑定。 
#### 8.2.2 产生正确的行为

#### 8.2.3 可扩展性

#### 8.2.4 缺陷：“覆盖”私有方法

#### 8.2.5 缺陷：域与静态方法

### 8.3 构造器和多态

#### 8.3.1 构造器的调用顺序

#### 8.3.2 继承与清理

#### 8.3.3 构造器内部的多态方法的行为

### 8.4 协变返回类型

### 8.5 用继承进行设计

#### 8.5.1 纯继承与扩展

#### 8.5.2 向下转型与运行时类型识别

### 8.6 总结

## 9 接口

### 9.1 抽象类和抽象方法

### 9.2 接口

### 9.3 完全解耦

### 9.4 Java 中的多重继承

### 9.5 通过继承来扩展接口

#### 9.5.1 组合接口时的名字冲突

### 9.6 适配接口

### 9.7 接口中的域

#### 9.7.1 初始化接口中的域

### 9.8 嵌套接口

### 9.9 接口与工厂

### 9.10 总结

## 10 内部类

### 10.1 创建内部类

### 10.2 链接到外部类

### 10.3 使用 .this 与 .new

### 10.4 内部类与向上转型

### 10.5 在方法和作用域内的内部类

### 10.6 匿名内部类

#### 10.6.1 再访工厂方法

### 10.7 嵌套类

#### 10.7.1 接口内部的类

#### 10.7.2 从多层嵌套类中访问外部类的成员

### 10.8 为什么需要内部类

1. 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立
2. 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。稍后就会展示一个这样的例子。
3. 创建内部类对象的时刻并不依赖于外围类对象的创建。
4. 内部类并没有令人迷惑的“is-a”关系；它就是一个独立的实体。

#### 10.8.1 闭包与回调

#### 10.8.2 内部类与控制框架

### 10.9 内部类的继承

### 10.10 内部类可以被覆盖码

### 10.11 局部内部类

### 10.12 内部类标识符

### 10.13 总结

## 11 持有对象

### 11.1 泛型和类型安全的容器

### 11.2 基本概念

1. Collection
2. Map

### 11.3 添加一组元素

### 11.4 容器的打印

### 11.5 List

### 11.6 迭代器

#### 11.6.1 ListIterator

### 11.7 LinkedList

### 11.8 Stack

### 11.9 Set

### 11.10 Map

### 11.11 Queue

#### 11.11.1 PriorityQueue

### 11.12 Collection 和 Iterator

### 11.13 Foreach 与 迭代器

#### 11.13.1 适配器方法惯用法

### 11.14 总结

1. 数组将数字与对象联系起来
2. Collection保存单一的元素
3. 像数组一样，List也建立数字索引与对象的关联
4. 如果要进行大量的随机访问，就使用 ArrayList ；如果经常从表中间插入或删除元素，则应该使用 LinkedList
5. 各种 Queue 以及栈的行为，用LinkedList 提供支持
6. Map 是一种将对象（而非数字）与对象关联的设计
7. Set 不接受重复元素
8. 新程序中不应该使用过时的 Vector、Hashtable 和 stack

## 12 通过异常处理错误

### 12.1 概念

### 12.2 基本异常

#### 12.2.1 异常参数

### 12.3 捕获异常

#### 12.3.1 try 块

#### 12.3.2 异常处理程序

### 12.4 创建自定义异常

#### 12.4.1 异常与记录日志

### 12.5 异常说明

### 12.6 捕获所有异常

#### 12.6.1 栈轨迹

#### 12.6.2 重新抛出异常

#### 12.6.3 异常链

### 12.7 Java 标准异常

#### 12.7.1 特例： RuntimeException

### 12.8 使用 finally 进行清理

#### 12.8.1 finally 用来做什么

#### 12.8.2 在 return 中 使用finally

#### 12.8.3 缺憾：异常丢失

### 12.9 异常的限制

### 12.10 构造器

### 12.11 异常匹配

### 12.12 其他可选方式

#### 12.12.1 历史

#### 12.12.2 观点

#### 12.12.3 把异常传递给控制台

#### 12.12.4 把“被检查的异常”转换为“不检查的异常”

### 12.13 异常使用指南

### 12.14 总结

## 13 字符串

### 13.1 不可变 String

### 13.2 重装 "+" 与 StringBuilder

### 13.3 无意识的递归

### 13.4 String 上的操作

### 13.5 格式化输出

#### 13.5.1 printf()

#### 13.5.2 System.out.format()

#### 13.5.3 Formatter 类

#### 13.5.4 格式化说明符

#### 13.5.5 Formatter 转换

#### 13.5.6 String.format()

### 13.6 正则表达式

#### 13.6.1 基础

#### 13.6.2 创建正则表达式

#### 13.6.3 量词

#### 13.6.4 Pattern 和 Matcher

#### 13.6.5 split()

#### 13.6.6 替换操作

#### 13.6.7 reset()

#### 13.6.8 正则表达式与 Java I/O

### 13.7 扫描输入

#### 13.7.1 Scanner 定界符

#### 13.7.2 用正则表达式扫描

### 13.8 StringTokenizer

### 13.9 总结

## 14 类型信息

### 14.1 为什么需要 RTTI

### 14.2 Class 对象

#### 14.2.1 类字面常量

#### 14.2.2 泛化的 Class 引用

#### 14.2.3 新的转型语法

### 14.3 类型转换前先做检查

#### 14.3.1 使用类字面常量

#### 14.3.2 动态的 instanceof

#### 14.3.3 递归计数

### 14.4 注册工厂

### 14.5 instanceof 与 Class 的等价性

### 14.6 反射：运行时的类信息

#### 14.6.1 类方法提取器

### 14.7 动态代理

### 14.8 空对象

#### 14.8.1 模拟对象与桩

### 14.9 接口与类型信息

### 14.10 总结

## 15 泛型

### 15.1 与 C++ 的比较

### 15.2 简单泛型

#### 15.2.1 一个元组类库

#### 15.2.2 一个堆栈类

#### 15.2.3 RandomList

### 15.3 泛型接口

### 15.4 泛型方法

#### 15.4.1 杠杆利用类型参数推断

#### 15.4.2 可变参数与泛型方法

#### 15.4.3 用 Generator 的泛型方法

#### 15.4.4 一个通用的 Generator

#### 15.4.5 简化元组的使用

#### 15.4.6 一个 Set 实用工具

### 15.5 匿名内部类

### 15.6 构建复杂模型

### 15.7 擦除的神秘之处

#### 15.7.1 C++ 的方式

#### 15.7.2 迁移兼容性

#### 15.7.3 擦除的问题

#### 15.7.4 边界处的动作

### 15.8 擦除的补偿

#### 15.8.1 创建类型实例

#### 15.8.2 泛型数组

### 15.9 边界

### 15.10 通配符

#### 15.10.1 编译器有多聪明

#### 15.10.2 逆变

#### 15.10.3 无界通配符

#### 15.10.4 捕获转换

### 15.11 问题

#### 15.11.1 任何基本类型都不能作为类型参数

#### 15.11.2 实现 参数化接口

#### 15.11.3 转型和警告

#### 15.11.4 重载

#### 15.11.5 基类劫持了接口

### 15.12 自限定的类型

#### 15.12.1 古怪的循环泛型

#### 15.12.2 自限定

#### 15.12.3 多数协变

### 15.13 动态类型安全

### 15.14 异常

### 15.15 混型

#### 15.15.1 C++ 中的混型

#### 15.15.2 与接口混合

#### 15.15.3 使用装饰器模式

#### 15.15.4 与动态代理混合

### 15.16 潜在类型机制

### 15.17 对缺乏潜在类型机制的补偿

#### 15.17.1 反射

#### 15.17.2 将一个方法应用于序列

#### 15.17.3 当你并未碰巧拥有正确的接口时

#### 15.17.4 用适配器仿真潜在类型机制

### 15.18 将函数对象用作策略

### 15.19 总结：转型真的如此之糟吗？

#### 15.19.1 进阶读物

## 16 数组

### 16.1 数组为什么特殊

### 16.2 数组是第一级对象

### 16.3 返回一个数组

### 16.4 多维数组

### 16.5 数组与泛型

### 16.6 创建测试数据

#### 16.6.1 Arrays.fill()

#### 16.6.2 数据生成器

#### 16.6.3 从 Generator 中创建数组

### 16.7 Arrays 实用功能

#### 16.7.1 复制数组

#### 16.7.2 数组的比较

#### 16.7.3 数组元素的比较

#### 16.7.4 数组排序

#### 16.7.5 在已排序的数组中查找

### 16.8 总结

## 17 容器深入研究

### 17.1 完整的容器分类法

### 17.2 填充容器

#### 17.2.1 一种 Generator 解决方案

#### 17.2.2 Map 生成器

#### 17.2.3 使用 Abstract 类

### 17.3 Collection 的功能方法

### 17.4 可选操作

#### 17.4.1 未获支持的操作

### 17.5 List 的功能方法

### 17.6 Set 和存储顺序

#### 17.6.1 SortedSet

### 17.7 队列

#### 17.7.1 优先级队列

#### 17.7.2 双向队列

### 17.8 理解 Map

#### 17.8.1 性能

#### 17.8.2 SortedMap

#### 17.8.3 LinkedHashMap

### 17.9 散列与散列码

#### 17.9.1 理解 hashCode()

#### 17.9.2 为速度而散列

#### 17.9.3 覆盖 hashCode()

### 17.10 选择接口的不同实现

#### 17.10.1 性能测试框架

#### 17.10.2 对 List 的选择

#### 17.10.3 微基准测试的危险

#### 17.10.4 对 Set 的选择

#### 17.10.5 对 Map 的选择

### 17.11 实用方法

#### 17.11.1 List 的排序和查询

#### 17.11.2 设定 Collection 或 Map 为不可修改

#### 17.11.3 Collection 或 Map 的 同步控制

### 17.12 持有引用

#### 17.12.1 WeakHashMap

### 17.13 Java 1.0/1.1 的容器

#### 17.13.1 Vector 和 Enumeration

#### 17.13.2 Hashtable

#### 17.13.3 Stack

#### 17.13.4 BitSet

### 17.14 总结

## 18 Java I/O 系统

### 18.1 File 类

#### 18.1.1 目录列表器

#### 18.1.2 目录实用工具

#### 18.1.3 目录的检查及创建

### 18.2 输入和输出

#### 18.2.1 InputStream 类型

#### 18.2.2 OutputStream 类型

### 18.3 添加属性和有用的接口

#### 18.3.1 通过FilterInputStream 从 InputStream 读取数据

#### 18.3.2 通过FilterOutputStream 向 OutputStream 写入

### 18.4 Reader 和 Writer

#### 18.4.1 数据的来源和去处

#### 18.4.2 更改流的行为

#### 18.4.3 未发生变化的类

### 18.5 自我独立的类：RandomAccessFile

### 18.6 I/O 流的典型使用方式

#### 18.6.1 缓冲输入文件

#### 18.6.2 从内存输入

#### 18.6.3 格式化的内存输入

#### 18.6.4 基本的文件输出

#### 18.6.5 存储和恢复数据

#### 18.6.6 读写随机访问文件

#### 18.6.7 管道流

### 18.7 文件读写的实用工具

#### 18.7.1 读取二进制文件

### 18.8 标准I/O

#### 18.8.1 从标准输入中读取

#### 18.8.2 将 System.out 转换成 PrintWriter

#### 18.8.3 标准 I/O 重定向

### 18.9 进程控制

### 18.10 新 I/O

#### 18.10.1 转换数据

#### 18.10.2 获取基本类型

#### 18.10.3 视图缓冲器

#### 18.10.4 用缓冲器操纵数据

#### 18.10.5 缓冲器的细节

#### 18.10.6 内存映射文件

#### 18.10.7 文件加锁

### 18.11 压缩

#### 18.11.1 用 GZIP 进行简单压缩

#### 18.11.2 用 ZIP 进行多文件保存

#### 18.11.3 Java 档案文件

### 18.12 对象序列化

#### 18.12.1 寻找类

#### 18.12.2 序列化的控制

#### 18.12.3 使用“持久性”

### 18.13 XML

### 18.14 Preferences

### 18.15 总结

## 19 枚举类型

### 19.1 基本 enum 特性

#### 19.1.1 将静态导入用于 enum

### 19.2 向 enum 中添加新方法

#### 19.2.1 覆盖 enum 的方法

### 19.3 switch 语句中的 enum

### 19.4 values() 的神秘之处

### 19.5 实现，而非继承

### 19.6 随机选取

### 19.7 使用接口组织枚举

### 19.8 使用 EnumSet 替代标志

### 19.9 使用 EnumMap

### 19.10 常量相关的方法

#### 19.10.1 使用 enum 的职责链

#### 19.10.2 使用 enum 的状态机

### 19.11 多路分发

#### 19.11.1 使用 enum 分发

#### 19.11.2 使用常量相关的方法

#### 19.11.3 使用 EnumMap 分发

#### 19.11.4 使用二维数组

### 19.12 总结

## 20 注解

### 20.1 基本语法

#### 20.1.1 定义注解

#### 20.1.2 元注解

### 20.2 编写注解处理器

#### 20.2.1 注解元素

#### 20.2.2 默认值限制

#### 20.2.3 生成外部文件

#### 20.2.4 注解不支持继承

#### 20.2.5 实现处理器

### 20.3 使用 apt 处理注解

### 20.4 将观察者模式用于 apt

### 20.5 基于注解的单元测试

#### 20.5.1 将 @Unit 用于泛型

#### 20.5.2 不需要任何“套件”

#### 20.5.3 实现 @Unit

#### 20.5.4 移除测试代码

### 20.6 总结

## 21 并发

### 21.1 并发的多面性

#### 21.1.1 更快的执行

#### 21.1.2 改进代码的设计

### 21.2 基本的线程机制

#### 21.2.1 定义任务

#### 21.2.2 Thread 类

#### 21.2.3 使用 Executor

#### 21.2.4 从任务中产生返回值

#### 21.2.5 休眠

#### 21.2.6 优先级

#### 21.2.7 让步

#### 21.2.8 后台线程

#### 21.2.9 编码的变体

#### 21.2.10 术语

#### 21.2.11 加入一个线程

#### 21.2.12 创建有响应的用户界面

#### 21.2.13 线程组

#### 21.2.14 捕获异常

### 21.3 共享受限资源

#### 21.3.1 不正确地访问资源

#### 21.3.2 解决共享资源竞争

#### 21.3.3 原子性与易变性

#### 21.3.4 原子类

#### 21.3.5 临界区

#### 21.3.6 在其他对象上同步

#### 21.3.7 线程本地存储

### 21.4 终结任务

#### 21.4.1 装饰性花园

#### 21.4.2 在阻塞时终结

#### 21.4.3 中断

#### 21.4.4 检查中断

### 21.5 线程之间的协作

#### 21.5.1 wait() 与 notifyAll()

#### 21.5.2 notify() 与 notifyAll()

#### 21.5.3 生产者与消费者

#### 21.5.4 生产者-消费者与duilie

#### 21.5.5 任务间使用管道进行输入/输出

### 21.6 死锁

### 21.7 新类库中的构件

#### 21.7.1 CountDownLatch

#### 21.7.2 CyclicBarrier

#### 21.7.3 DelayQueue

#### 21.7.4 PriorityBlockingQueue

#### 21.7.5 使用 ScheduledExecutor 的温室控制器

#### 21.7.6 Semaphore

#### 21.7.7 Exchanger

### 21.8 仿真

#### 21.8.1 银行出纳员仿真

#### 21.8.2 饭店仿真

#### 21.8.3 分发工作

### 21.9 性能调优

#### 21.9.1 比较各类互斥技术

#### 21.9.2 免锁容器

#### 21.9.3 乐观加锁

#### 21.9.4 ReadWriteLock

### 21.10 活动对象

### 21.11 总结

#### 21.11.1 进阶读物

## 22 图形化用户界面

### 22.1 applet

### 22.2 Swing 基础

#### 22.2.1 一个显示框架

### 22.3 创建按钮

### 22.4 捕获事件

### 22.5 文本区域

### 22.6 控制布局

#### 22.6.1 BorderLayout

#### 22.6.2 FlowLayout

#### 22.6.3 GridLayout

#### 22.6.4 GridBagLayout

#### 22.6.5 绝对定位

#### 22.6.6 BoxLayout

#### 22.6.7 最好的方式是什么

### 22.7 Swing 时间模型

#### 22.7.1 事件与监听器的类型

#### 22.7.2 跟踪多个事件

### 22.8 Swing 组件一览

#### 22.8.1 按钮

#### 22.8.2 图标

#### 22.8.3 工具提示

#### 22.8.4 文本域

#### 22.8.5 边框

#### 22.8.6 一个迷你编辑器

#### 22.8.7 复选框

#### 22.8.8 单选按钮

#### 22.8.9 组合框

#### 22.8.10 列表框

#### 22.8.11 页签面板

#### 22.8.12 消息框

#### 22.8.13 菜单

#### 22.8.14 弹出式菜单

#### 22.8.15 绘图

#### 22.8.16 对话框

#### 22.8.17 文件对话框

#### 22.8.18 Swing 组件上的 HTML

#### 22.8.19 滑块与进度条

#### 22.8.20 选择外观

#### 22.8.21 树、表格和剪贴板

### 22.9 JNLP 与 Java Web Start

### 22.10 Swing 与 并发

#### 22.10.1 长期运行的任务

#### 22.10.2 可视化线程机制

### 22.11 可视化编程与 JavaBean

#### 22.11.1 JavaBean 是什么

#### 22.11.2 使用 Introspector 抽出 BeanInfo

#### 22.11.3 一个更复杂的 Bean

#### 22.11.4 JavaBean 与同步

#### 22.11.5 把 Bean 打包

#### 22.11.6 对 Bean 更高级的支持

#### 22.11.7 有关 Bean 的其他读物

### 22.12 Swing 的可替代选择

### 22.13 用 Flex 构建 Flash Web 客户端

#### 22.13.1 Hello, Flex

#### 22.13.2 编译 MXML

#### 22.13.3 MXML 与 ActionScript

#### 22.13.4 容器与控制

#### 22.13.5 效果与样式

#### 22.13.6 事件

#### 22.13.7 连接到 Java

#### 22.13.8 数据模型与数据绑定

#### 22.13.9 构建和部署

### 22.14 创建 SWT 应用

#### 22.14.1 安装 SWT 应用

#### 22.14.2 Hello, SWT

#### 22.14.3 根除冗余代码

#### 22.14.4 菜单

#### 22.14.5 页签面板、按钮和事件

#### 22.14.6 图形

#### 22.14.7 SWT中的并发

#### 22.14.8 SWT 还是 Swing

### 22.15 总结

#### 22.15.1 资源

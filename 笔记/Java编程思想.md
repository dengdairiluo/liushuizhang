# Java 编程思想

## 1 对象导论

### 1.1 抽象过程

一种面向对象程序设计方式：
1. 万物皆对象
2. 程序是对象的集合
3. 每个对象都有自己的由其他对象所构成的存储
4. 每个对象都拥有其类型。
5. 某一特定类型的所有对象都可以接收同样的消息

### 1.2 每个对象都有一个接口

### 1.3 每个对象都提供服务

### 1.4 被隐藏的具体实现

### 1.5 复用具体实现

### 1.6 继承

#### 1.6.1 “是一个” 与 “像是一个”关系

### 1.7 伴随多态的可互换对象

### 1.8 单根继承结构

### 1.9 容器

#### 1.9.1 参数化类型

### 1.10 对象的创建和生命期

### 1.11 异常处理：处理错误

### 1.12 并发编程

### 1.13 Java 与 Internet

#### 1.13.1 Web 是什么

1. 客户/服务器计算技术
2. Web 就是一台巨型服务器

#### 1.13.2  客户端编程

1. 插件
2. 脚本语言
3. Java
4. 备选方案
5. .Net 和 C#
6.  Internet 与 Intranet

#### 1.13.3 服务器端编程

### 1.14 总结

## 2 一切皆对象

### 2.1 用引用操纵对象

### 2.2 必须由你创建所有对象

#### 2.2.1 存储到什么地方

1. 寄存器
2. 堆栈
3. 堆
4. 常量存储
5. 非RAM存储

#### 2.2.2 特例：基本类型

#### 2.2.3 Java 中的数组

### 2.3 永远不需要销毁对象

#### 2.3.1 作用域

#### 2.3.2 对象的作用域

### 2.4 创建新的数据类型：类

#### 2.4.1 字段和方法

### 2.5 方法、参数和返回值

#### 2.5.1 参数列表

### 2.6 构建一个 Java 程序

#### 2.6.1 名字可见性

#### 2.6.2 运行其他构件

#### 2.6.3 static 关键字

### 2.7 你的第一个 Java 程序

#### 2.7.1 编译和运行

### 2.8 注释和嵌入式文档

#### 2.8.1 注释文档

#### 2.8.2 语法

#### 2.8.3 嵌入式 HTML

#### 2.8.4 一些标签示例

#### 2.8.5 文档示例

### 2.9 编码风格

### 2.10 总结

### 2.11 练习

## 3 操作符

### 3.1 更简单的打印语句

### 3.2 使用 Java 操作符

### 3.3 优先级

### 3.4 赋值

#### 3.4.1 方法调用中的别名问题

### 3.5 算术操作符

#### 3.5.1 一元加、减操作符

### 3.6 自动递增和递减

### 3.7 关系操作符

#### 3.7.1 测试对象的等价性

### 3.8 逻辑操作符

#### 3.8.1 短路

### 3.9 直接常量

#### 3.9.1 指数记数法

### 3.10 按位操作符

### 3.11 移位操作符
 
### 3.12 三元操作符 if-else

### 3.13 字符串操作符 + 和 +=

### 3.14 使用操作符时常犯的错误

### 3.15 类型转换操作符

#### 3.15.1 截尾和舎入

#### 3.15.2 提升

### 3.16 Java 没有 sizeof

### 3.17 操作符小结

### 3.18 总结

## 4 控制执行流程

### 4.1 true 和 false

### 4.2 if-else

### 4.3 迭代

#### 4.3.1 do-while

#### 4.3.2 for

#### 4.3.3 逗号操作符

### 4.4 Foreach 语法

### 4.5 return

### 4.6 break 和 continue

### 4.7 臭名昭著的 goto

### 4.8 switch

### 4.9 总结

## 5 初始化与清理

### 5.1 用构造器确保初始化

### 5.2 方法重载

#### 5.2.1 区分重载方法

#### 5.2.2 涉及基本类型的重载

#### 5.2.3 以返回值区分重载方法

### 5.3 默认构造器

### 5.4 this 关键字

#### 5.4.1 在构造器中调用构造器

#### 5.4.2 static 的含义

### 5.5 清理：终结处理和垃圾回收

#### 5.5.1 finalize() 的用途何在

#### 5.5.2 你必须实施清理

#### 5.5.3 终结条件

#### 5.5.4 垃圾回收器如何工作

### 5.6 成员初始化

#### 5.6.1 指定初始化

### 5.7 构造器初始化

#### 5.7.1 初始化顺序

#### 5.7.2 静态数据的初始化

#### 5.7.3 显式的静态初始化

#### 5.7.4 非静态实例初始化

### 5.8 数组初始化

#### 5.8.1 可变参数列表

### 5.9 枚举类型

### 5.10 总结

## 6 访问权限控制

### 6.1 包：库单元

#### 6.1.1 代码组织

#### 6.1.2 创建独一无二的包名

#### 6.1.3 定制工具库

#### 6.1.4 用 import 改变行为

#### 6.1.5 对使用包的忠告

### 6.2 Java 访问权限修饰词

#### 6.2.1 包访问权限

#### 6.2.2 pubic：接口访问权限

#### 6.2.3 private：你无法访问

#### 6.2.4 protected：继承访问权限

### 6.3 接口和实现

### 6.4 类的访问权限

### 6.5 总结

## 7 复用类

### 7.1 组合语法

### 7.2 继承语法

#### 7.2.1 初始化基类

### 7.3 代理

### 7.4 结合使用组合和继承

#### 7.4.1 确保正确清理

#### 7.4.2 名称屏蔽

### 7.5 在组合与继承之间选择

### 7.6 protected 关键字

### 7.7 向上转型

#### 7.7.1 为什么称为向上转型

#### 7.7.2 再论组合与继承

### 7.8 final 关键字

#### 7.8.1 final 数据

#### 7.8.2 final 方法

#### 7.8.3 final 类

#### 7.8.4 有关 final 的忠告

### 7.9 初始化及类的加载

#### 7.9.1 继承与初始化

### 7.10 总结

## 8  多态

### 8.1 再论向上转型

#### 8.1.1 忘记对象类型

### 8.2 转机

#### 8.2.1 方法调用绑定

#### 8.2.2 产生正确的行为

#### 8.2.3 可扩展性

#### 8.2.4 缺陷：“覆盖”私有方法

#### 8.2.5 缺陷：域与静态方法

### 8.3 构造器和多态

#### 8.3.1 构造器的调用顺序

#### 8.3.2 继承与清理

#### 8.3.3 构造器内部的多态方法的行为

### 8.4 协变返回类型

### 8.5 用继承进行设计

#### 8.5.1 纯继承与扩展

#### 8.5.2 向下转型与运行时类型识别

### 8.6 总结

## 9 接口

### 9.1 抽象类和抽象方法

### 9.2 接口

### 9.3 完全解耦

### 9.4 Java 中的多重继承

### 9.5 通过继承来扩展接口

#### 9.5.1 组合接口时的名字冲突

### 9.6 适配接口

### 9.7 接口中的域

#### 9.7.1 初始化接口中的域

### 9.8 嵌套接口

### 9.9 接口与工厂

### 9.10 总结

## 10 内部类

### 10.1 创建内部类

### 10.2 链接到外部类

### 10.3 使用 .this 与 .new

### 10.4 内部类与向上转型

### 10.5 在方法和作用域内的内部类

### 10.6 匿名内部类

#### 10.6.1 再访工厂方法

### 10.7 嵌套类

#### 10.7.1 接口内部的类

#### 10.7.2 从多层嵌套类中访问外部类的成员

### 10.8 为什么需要内部类

#### 10.8.1 闭包与回调

#### 10.8.2 内部类与控制框架

### 10.9 内部类的继承

### 10.10 内部类可以被覆盖码

### 10.11 局部内部类

### 10.12 内部类标识符

### 10.13 总结

## 11 持有对象

### 11.1 泛型和类型安全的容器

### 11.2 基本概念

### 11.3 添加一组元素

### 11.4 容器的打印

### 11.5 List

### 11.6 迭代器

#### 11.6.1 ListIterator

### 11.7 LinkedList

### 11.8 Stack

### 11.9 Set

### 11.10 Map

### 11.11 Queue

#### 11.11.1 PriorityQueue

### 11.12 Collection 和 Iterator

### 11.13 Foreach 与 迭代器

#### 11.13.1 适配器方法惯用法

### 11.14 总结

## 12 通过异常处理错误

### 12.1 概念

### 12.2 基本异常

#### 12.2.1 异常参数

### 12.3 捕获异常

#### 12.3.1 try 块

#### 12.3.2 异常处理程序

### 12.4 创建自定义异常

#### 12.4.1 异常与记录日志

### 12.5 异常说明

### 12.6 捕获所有异常

#### 12.6.1 栈轨迹

#### 12.6.2 重新抛出异常

#### 12.6.3 异常链

### 12.7 Java 标准异常

#### 12.7.1 特例： RuntimeException

### 12.8 使用 finally 进行清理

#### 12.8.1 finally 用来做什么

#### 12.8.2 在 return 中 使用finally

#### 12.8.3 缺憾：异常丢失

### 12.9 异常的限制

### 12.10 构造器

### 12.11 异常匹配

### 12.12 其他可选方式

#### 12.12.1 历史

#### 12.12.2 观点

#### 12.12.3 把异常传递给控制台

#### 12.12.4 把“被检查的异常”转换为“不检查的异常”

### 12.13 异常使用指南

### 12.14 总结

## 13 字符串

### 13.1 不可变 String

### 13.2 重装 "+" 与 StringBuilder

### 13.3 无意识的递归

### 13.4 String 上的操作

### 13.5 格式化输出

#### 13.5.1 printf()

#### 13.5.2 System.out.format()

#### 13.5.3 Formatter 类

#### 13.5.4 格式化说明符

#### 13.5.5 Formatter 转换

#### 13.5.6 String.format()

### 13.6 正则表达式

#### 13.6.1 基础

#### 13.6.2 创建正则表达式

#### 13.6.3 量词

#### 13.6.4 Pattern 和 Matcher

#### 13.6.5 split()

#### 13.6.6 替换操作

#### 13.6.7 reset()

#### 13.6.8 正则表达式与 Java I/O

### 13.7 扫描输入

#### 13.7.1 Scanner 定界符

#### 13.7.2 用正则表达式扫描

### 13.8 StringTokenizer

### 13.9 总结

## 14 类型信息

### 14.1 为什么需要 RTTI

### 14.2 Class 对象

#### 14.2.1 类字面常量

#### 14.2.2 泛化的 Class 引用

#### 14.2.3 新的转型语法

### 14.3 类型转换前先做检查

#### 14.3.1 使用类字面常量

#### 14.3.2 动态的 instanceof

#### 14.3.3 递归计数

### 14.4 注册工厂

### 14.5 instanceof 与 Class 的等价性

### 14.6 反射：运行时的类信息

#### 14.6.1 类方法提取器

### 14.7 动态代理

### 14.8 空对象

#### 14.8.1 模拟对象与桩

### 14.9 接口与类型信息

### 14.10 总结



# 深入拆解Java虚拟机

## 0.为什么我们要学校java 虚拟机

*   基本原理
*   高效实现
*   代码优化
*   虚拟机黑科技

## 1.Java代码是怎么运行的

### 为什么Java要在虚拟机里运行

java代码 编译成class文件加载到Java虚拟机中，加载后的Java会被存放于方法区中，实际运行会执行方法区内的代码。

* Java虚拟机
  * 线程共享
    * 方法区
    * 栈
  * 线程私有
    * PC寄存器
    * Java方法栈
    * 本地方法栈

在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java **虚拟机不要求栈帧在内存空间里连续分布**。

## 2. Java的基本类型

### Java 虚拟机的 boolean 类型

在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。

### Java 的基本类型

除了上面提到的 boolean 类型外，Java 的基本类型还包括整数类型 byte、short、char、int 和 long，以及浮点类型 float 和 double。
   
### Java 基本类型的大小

也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。

### 总结

其中，boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。

除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。

除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。


## Java虚拟机是如何加载Java类的?

### 加载

**加载：**是指查找字节流，并且据此创建类的过程。

**双亲委派模型**

### 链接

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。

准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。

解析阶段的目的，正是将这些符号引用解析成为实际引用。

### 初始化

那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：

当虚拟机启动时，初始化用户指定的主类；
当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
当遇到调用静态方法的指令时，初始化该静态方法所在的类；
当遇到访问静态字段的指令时，初始化该静态字段所在的类；
子类的初始化会触发父类的初始化；
如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
使用反射 API 对某个类进行反射调用时，初始化这个类；
当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

### 总结与实践

今天我介绍了 Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。
加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。
链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。
初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

## JVM如何执行方法调用的（上）

### 重载与重写

**重载：**参数不同
1. 不考虑自动拆装箱，不考虑可变参数
2. 考虑自动装拆箱， 不考虑可变参数
3. 都考虑
   
### JVM的静态绑定和动态绑定
  
### 调用指令的符号引用

## JVM如何执行方法调用的（下）

### 虚方法调用

### 方法表

### 内联缓存

## JVM 是如何处理异常的


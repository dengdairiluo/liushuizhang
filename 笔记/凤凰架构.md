# 凤凰架构：构建可靠的大型分布式系统

## 1 服务架构演进史

### 1.1 原始分布式时代

### 1.2 单体系统时代

### 1.3 SOA时代

* 烟囱式架构
* 微内核架构
* 事件驱动架构

### 1.4 微服务时代

* 围绕业务能力构建
* 分散治理
* 通过服务来实现独立自治的组件
* 产品化思维
* 数据去中心化
* 强终端弱管道
* 容错性设计
* 演进式设计
* 基础设施自动化

### 1.5 后服务时代

### 1.6 无服务时代

* 后端设施
* 函数

## 2 访问远程服务

### 2.1 远程服务调用

程序执行函数的流程：

1. 传递方法参数
2. 确定方法版本
3. 执行被调方法
4. 返回执行结果

#### 2.1.1 进程间通信

* 管道
* 信号
* 信号量
* 消息队列
* 共享内存
* 本地套接字接口

#### 2.1.2 通信成本

#### 2.1.3 三个基本问题

1. 如何表示数据
2. 如何传递数据
3. 如何表示方法

#### 2.1.4 统一的RPC

#### 2.1.5 分裂的RPC

* 朝着面向对象发展
* 朝着性能发展
* 朝着简化发展

### 2.2 REST设计风格

#### 2.2.1 理解REST

#### 2.2.2 RESTful的系统

1. 客户端与服务器分离
2. 无状态
3. 可缓存
4. 分层系统
5. 统一接口
6. 按需代码

#### 2.2.3 RMM

* 第0级：完全不REST
* 第1级：开始引入资源的概念
* 第2级：引入统一接口
* 第3级：超媒体控制

#### 2.2.4 不足与争议

1. 面向资源的变成思想只适合做CRUD，面向过程、面向对象编程才能处理真正复杂的业务逻辑。
2. REST与HTTP完全绑定，不适合应用于要求高性能传输的场景中。
3. REST不利于事务支持。
4. REST没有传输可靠性支持。
5. REST缺乏对资源进行“部分”和“批量”处理的能力。

## 3 事务处理

* 原子性
* 隔离性
* 持久性

### 3.1 本地事务

#### 3.1.1 实现原子性和持久性

* 未提交事务，写入后崩溃
* 已提交事务，写入前崩溃

崩溃恢复3个阶段：

1. 分析阶段
2. 重做阶段
3. 回滚阶段

#### 3.1.2 实现隔离性

* 写锁
* 读锁
* 范围锁

### 3.2 全局事务

* 准备阶段
* 提交阶段

缺点：

* 单点问题
* 性能问题
* 一致性风险

### 3.3 共享事务

### 3.4 分布式事务

#### 3.4.1 CAP与ACID

* 一致性 C
* 可用性 A
* 分区容忍性 P

#### 3.4.2 可靠事件队列

#### 3.4.3 TCC事务

* Try 尝试执行阶段
* Confirm 确认执行阶段
* Cancel 取消执行阶段

#### 3.4.4 SAGA事务

记账式

## 4 透明多级分流系统

### 4.1 客户端缓存

#### 4.1.1 强制缓存

1. Expires
2. Cache-Control

#### 4.1.2 协商缓存

1. Last-Modified和If-Modified-Since
2. ETag和If-None-Match

### 4.2 域名解析

### 4.3 传输链路

1. 减少请求数量
2. 扩大并发请求数
3. 启用压缩传输
4. 避免页面重定向
5. 按重要性调节资源优先级

#### 4.3.1 连接数优化

#### 4.3.2 传输压缩

#### 4.3.3 快速UDP网络连接

### 4.4 内容分发网络

#### 4.4.1 路由解析

#### 4.4.2 内容分发

* 主动分发
* 被动回源

#### 4.4.3 CDN应用

* 加速静态资源分发
* 安全防御
* 协议升级
* 状态缓存
* 修改资源
* 访问控制
* 注入功能

### 4.5 负载均衡

1. 应用层
2. 表达层
3. 会话层
4. 传输层
5. 网络层
6. 数据链路层
7. 物理层

#### 4.5.1 数据链路负载均衡

#### 4.5.2 网络层负载均衡

#### 4.5.3 应用层负载均衡

#### 4.5.4 均衡策略与实现

* 轮询均衡
* 权重轮询均衡
* 随机均衡
* 权重随机均衡
* 一致性哈希均衡
* 响应速度均衡
* 最少连接数均衡

### 4.6 服务端缓存

#### 4.6.1 缓存属性

##### 4.6.1.1 吞吐量

##### 4.6.1.2 命中率与淘汰策略

* FIFO
* LRU
* LFU
* TinyLFU
* W-TinyLFU

##### 4.6.1.3 扩展功能

* 加载器
* 淘汰策略
* 失效策略
* 事件通知
* 并发级别
* 容量控制
* 引用方式
* 统计信息
* 持久化

##### 4.6.1.4 分布式缓存

* 复制式缓存
* 集中式缓存

#### 4.6.2 缓存风险

1. 缓存穿透
2. 缓存击穿
3. 缓存雪崩
4. 缓存污染

## 5 架构安全性

### 5.1 认证

#### 5.1.1 认证的标准

* 通信信道上的认证
* 通信协议上的认证
* 通信内容上的认证

1. HTTP认证
2. Web认证

#### 5.1.2 认证的实现

### 5.2 授权

* 确保授权的过程可靠
* 确保授权的结果可靠

#### 5.2.1 RBAC

#### 5.2.2 Oauth2

### 5.3 凭证

#### 5.3.1 Cookie-Session

#### 5.3.2 JWT

### 5.4 保密

#### 5.4.1 保密的强度

1. 以摘要代替明文
2. 先加盐值再做哈希
3. 将盐值变为动态值
4. 给服务加入动态令牌
5. 启用HTTPS
6. 进一步提升保密强度

#### 5.4.2 客户端加密

#### 5.4.3 密码存储和验证

### 5.5 传输

#### 5.5.1 摘要、加密与签名

#### 5.5.2 数字证书

* 基于共同私密信息的信任
* 基于权威公证人的信任

#### 5.5.3 传输安全层

1. 客户端请求：Client Hello
2. 服务器回应：Server Hello
3. 客户端确认：Client Handshake Finished
4. 服务器确认：Server Handshake Finished

### 5.6 验证

## 6 分布式共识

### 6.1 Paxos

#### 6.1.1 Paxos的诞生

#### 6.1.2 算法流程

* 提案节点
* 决策节点
* 记录节点

#### 6.1.3 工作实例

### 6.2 Multi Paxos

### 6.3 Gossip协议

## 7 从类库到服务

### 7.1 服务发现

#### 7.1.1 服务发现的意义

#### 7.1.2 可用与可靠

* 服务的注册
* 服务的维护
* 服务的发现

#### 7.1.3 注册中心实现

### 7.2 网关路由

#### 7.2.1 网关的职责

#### 7.2.2 网络I/O模型

* 异步I/O
* 同步I/O
* 阻塞I/O
* 非阻塞I/O
* 多路复用I/O
* 信号驱动I/O

#### 7.2.3 BFF网关

### 7.3 客户端负载均衡

#### 7.3.1 客户端负载均衡器

#### 7.3.2 代理负载均衡器

#### 7.3.3 地域与区域

## 8 流量治理

### 8.1 服务容错

* 故障转移
* 快速失败
* 安全失败
* 沉默失败
* 故障恢复

* 并行调用
* 广播调用

#### 8.1.1 容错策略

#### 8.1.2 容错设计模式

1. 断路器模式
2. 舱壁隔离模式
3. 重试模式

### 8.2 流量控制

* 依据什么限流
* 具体如何限流
* 超额流量如何处理

#### 8.2.1 流量统计指标

* 每秒事务数TPS
* 每秒请求数HPS
* 每秒查询数QPS

#### 8.2.2 限流设计模式

1. 流量计数器模式
2. 滑动时间窗模式
3. 漏桶模式
4. 令牌桶模式

#### 8.2.3 分布式限流

## 9 可靠通信

### 9.1 零信任网络

#### 9.1.1 零信任安全模型的特征

* 零信任网络不等同于放弃在边界上的保护设施
* 身份只来源于服务
* 服务之间没有固有的信任关系
* 集中、共享的安全策略实施点
* 受信的机器运行来源已知的代码
* 自动化、标注化的变更管理
* 强隔离性的工作负载

#### 9.1.2 Google的实践探索

### 9.2 服务安全

#### 9.2.1 建立信任

* 单向TLS认证
* 双向TLS认证

#### 9.2.2 认证

1. 服务认证
2. 用户认证

#### 9.2.3 授权

## 10 可观测性

* 日志
* 追踪
* 度量

### 10.1 事件日志

#### 10.1.1 输出

#### 10.1.2 收集与缓冲

#### 10.1.3 加工与聚合

#### 10.1.4 存储与查询

### 10.2 链路追踪

#### 10.2.1 追踪与跨度

#### 10.2.2 数据收集

#### 10.2.3 追踪规范化

### 10.3 聚合度量

#### 10.3.1 指标收集

#### 10.3.2 存储查询

#### 10.3.3 监控预警

## 11 虚拟化容器

### 11.1 容器的崛起

#### 11.1.1 隔离文件：chroot

#### 11.1.2 隔离访问：名称空间

#### 11.1.3 隔离资源：cgroups

#### 11.1.4 封装系统：LXC

#### 11.1.5 封装应用：Docker

#### 11.1.6 封装集群：Kubernetes

### 11.2 以容器构建系统

#### 11.2.1 隔离与协作

#### 11.2.2 韧性与弹性

### 11.3 以应用为中心的封装

#### 11.3.1 Kustomize

#### 11.3.2 Helm与Chart

#### 11.3.3 Operator与CRD

#### 11.3.4 开放应用模型

## 12 容器间网络

### 12.1 Linux网络虚拟化

#### 12.1.1 网络通信模型

#### 12.1.2 干预网络通信

#### 12.1.3 虚拟化网络设备

#### 12.1.4 容器间通信

### 12.2 容器网络与生态

#### 12.2.1 CNM与CNI

#### 12.2.2 CNM到CNI

#### 12.2.3 网络插件生态

## 13 持久化存储

### 13.1 Kunbernetes存储设计

#### 13.1.1 Mount和Volume

#### 13.1.2 静态存储分配

#### 13.1.3 动态存储分配

### 13.2 容器存储与生态

#### 13.2.1 Kubernetes存储架构

#### 13.2.2 FlexVolume与CSI

#### 13.2.3 从In-Tree到Out-of-Tree

#### 13.2.4 容器插件生态

## 14 资源与调度

### 14.1 资源类型

### 14.2 服务质量与优先级

### 14.3 驱逐机制

### 14.4 默认调度器

## 15 服务网格

### 15.1 透明通信的涅槃

#### 15.1.1 通信成本

#### 15.1.2 数据平面

#### 15.1.3 控制平面

### 15.2 服务网格与生态

#### 15.2.1 服务网格接口

#### 15.2.2 通用数据平面API

#### 15.2.3 服务网格生态

## 16 向微服务迈进

### 16.1 目的：微服务的驱动力

### 16.2 前提：微服务需要的条件

### 16.3 边界：微服务的粒度

### 16.4 治理：理解系统复杂性

#### 16.4.1 静态的治理

#### 16.4.2 发展的治理

# MySQL实战45讲

## 0.开篇词 

从点到线，再到面，形成自己的MySQL知识网络

## 1.基础架构：一条SQL查询语句是如何执行的

**连接器** ：用户名密码验证，验证通过后获取权限

**查询缓存**
但是大多数情况下建议不使用查询缓存，因为弊大于利

**分析器**

**优化器**

**执行器**

## 2.日志系统：一条SQL更新语句是如何执行的

### 重要日志模块： redo log ，bin log

redo log crash-safe
bin log 

**不同：**

* redo log InnoDB 特有； bin log MySQL Server层实现。
* redo log 是物理日志，记录在某个数据页上做了什么修改； binlog 是逻辑日志记录语句原始逻辑
* redo log 循环写，空间固定会用完；binlog 追加写入的。binlog文件写完一定大小后会切换到下一个
  
  **两阶段提交**

##  3 事务隔离：为什么你改了我还看不见？

### 隔离性与隔离级别

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）

* 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
* 读提交是指，一个事务提交之后，它做的变更就能被别的事务看到。
* 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
* 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

## 4 深入浅出索引（上）

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。


###  索引的常见类型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。

#### 哈希表

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

哈希表这种结构适用于只有等值查询的场景

#### 有序数组
有序数组在等值查询和范围查询场景中的性能就都非常优秀

### InnoDB 的索引模型

每一个索引在 InnoDB 里面对应一棵 B+ 树。

基于主键索引和普通索引的查询有什么区别？

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。


### 索引维护

显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

## 深入浅出索引（下）

**回表：** 回到逐渐索引树搜索的过程。

### 覆盖索引

由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

### 最左前缀原则

B+ 树 这种索引结构，可以利用索引的“最左前缀”，来定位记录

在建立联合索引的时候，如何安排索引内的字段顺序。

1. 如果调整顺序可以减少维护一个索引，那么这个顺序往往就需要优先考虑采用的。
2. 空间

### 索引下推

## 全局锁和表锁：给表加个字段怎么又这么多阻碍

根据加锁范围，MySQL里锁分为3类
* 全局锁
* 表级锁
* 行锁
  
  ### 全局锁

  典型使用场景， 全库逻辑备份


  ### 表级锁

* 表锁
* 元数据锁

* lock table
* MDL



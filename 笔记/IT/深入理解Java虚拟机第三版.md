# 深入理解Java虚拟机第三版

## 1 走近Java

### 1.1 概述

### 1.2 Java技术体系

### 1.3 Java发展史

### 1.4 Java虚拟机家族

#### 1.4.1 虚拟机始祖：SunClassic/Exact VM

#### 1.4.2 武林盟主：HotSpot VM

#### 1.4.3 小家碧玉：Mobile/Embedded VM

#### 1.4.4 天下第二：BEA JRockit/IBM J9 VM

#### 1.4.5 软硬合璧：BEA Liquid VM/Azul VM

#### 1.4.6 挑战者：Apache Harmony/Google Android Dalvik VM

#### 1.4.7 没有成功，但并非失败：Mircosoft JVM及其他

#### 1.4.8 百家争鸣

### 1.5 展望Java技术的未来

#### 1.5.1 无语言倾向

#### 1.5.2 新一代即时编译器

#### 1.5.3 向Native迈进

#### 1.5.4 灵活的胖子

#### 1.5.5 语言语法持续增强

### 1.6 实战：自己编译JDK

#### 1.6.1 获取源码

#### 1.6.2 系统需求

#### 1.6.3 构建编译环境

#### 1.6.4 进行编译

### 1.7 本章小结

## 2 Java内存区域与内存溢出异常

### 2.1 概述

### 2.2 运行时数据区域

#### 2.2.1 程序计数器

#### 2.2.2 Java虚拟机栈

#### 2.2.3 本地方法栈

#### 2.2.4 Java堆

#### 2.2.5 方法区

#### 2.2.6 运行时常量池

#### 2.2.7 直接内存

### 2.3 HotSpot虚拟机对象探秘

#### 2.3.1 对象的创建

#### 2.3.2 对象的内存布局

#### 2.3.3 对象的访问定位

### 2.4 实战：OutOfMemoryError异常

#### 2.4.1 Java堆溢出

#### 2.4.2 虚拟机栈和本地方法栈溢出

#### 2.4.3 方法区和运行时常量池溢出

#### 2.4.4 本机直接内存溢出

### 2.5 本章小结

## 3 垃圾收集器与内存分配策略

### 3.1 概述

### 3.2 对象已死

#### 3.2.1 引用计数法

#### 3.2.2 可达性分析算法

#### 3.2.3 再谈引用

#### 3.2.4 生成还是死亡

#### 3.2.5 回收方法区

### 3.3 垃圾收集算法

#### 3.3.1 分代收集理论

#### 3.3.2 标记-清除算法

#### 3.3.3 标记-复制算法

#### 3.3.4 标记-整理算法

### 3.4 HotSpot的算法细节实现

#### 3.4.1 根节点枚举

#### 3.4.2 安全点

#### 3.4.3 安全区域

#### 3.4.4 记忆集与卡表

#### 3.4.5 写屏障

#### 3.4.6 并发的可达性分析

### 3.5 经典垃圾收集器

#### 3.5.1 Serial收集器

#### 3.5.2 ParNew收集器

#### 3.5.3 Parallel Scavenge收集器

#### 3.5.4 Serial Old收集器

#### 3.5.5 Prallel Old收集器

#### 3.5.6 CMS收集器

#### 3.5.7 Garbage First收集器

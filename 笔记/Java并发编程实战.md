# Java并发编程实战

## 1.你为什么要学并发编程
并发 = 分工 + 同步 + 互斥

**分工**：如何高效地拆解任务并分配给线程

**同步** ： 线程之间如何协作

**互斥**： 保证同一时刻只允许一个线程访问共享资源

## 2. 如何才能学好并发 编程

### 分工
### 同步
一个线程执行完了一个任务，如何通知执行后续任务的线程开工

当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行

管程是解决并发问题的万能钥匙

### 互斥（线程安全）
**互斥：** 同一时刻，只允许一个线程访问共享变量


### 并发编程结构

* 并发编程
  * 协作
    * 信号量
    * 管程 
      * Lock&Condition
      * synchronized
    * CountDownLatch
    * CyclicBarrier
    * Phaser
    * Exchanger
  * 互斥
    * 无锁
      * 不变模式
      * 线程本地存储
      * CAS
      * Copy-on-Write
      * 原子类
    * 互斥锁
      * synchronized
  * 分工
    * Exeutor与线程池
    * Fork/Join
    * Future
    * Guarded Suspension模式
    * BalKing模式
    * Thread-Per-Message模式
    * 生产者-消费者模式
    * Worker Thread模式
    * 两阶段终止模式

工程上的解决方案，一定要有理论基础

## 01 可见性、原子性和有序性问题：并发编程Bug的源头

### 并发程序幕后的故事

为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：
* CPU 增加了缓存，以均衡与内存的速度差异；
* 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异;
* 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

### 缓存导致的可见性问题

**可见性：** 一个线程对共享变量的修改，另外一个线程能够立刻看到。

### 线程切换带来的原子性问题

操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。

**原子性：** 我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性。

### 编译优化带来的有序性问题
有序性：程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，编译器调整了语句的顺序，但是不影响程序的最终结果。


只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。

##  Java内存模型：看Java如何解决可见性和有序性问题

### 什么是 Java 内存模型？

按需禁用缓存以及编译优化。

Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。

### 使用 volatile 的困惑

**volatile：**  对这个变量读写不能使用CPU缓存

### Happens-Before 规则

前面一个操作的结果对后续操作是可见的

1. 程序的顺序性规则
2. volatile变量规则
3. 传递性
4. 管程中锁的规则
5. 线程start() 规则
6. 线程join()规则
7. 被我们忽视的final

## 互斥锁（上）：解决原子性问题

### 原子性问题如何解决

原子性问题的源头是线程切换.

long 在32位机上并发问题

**互斥：** 同一时刻只有一个线程执行

#### 简易锁模型

#### 改进后的锁模型

#### Java 语言提供的锁技术： synchronized

用synchronized 解决count += 1 的问题

## 互斥锁（下）：如何用一把锁保护多个资源

受保护资源和锁之间的合理的关联关系应该是N：1的关系


### 保护没有关联关系的多个资源

**细粒度锁：** 用不同的锁对受保护资源进行精细化管理，能够提升性能。

### 保护有关联关系的多个资源

### 使用锁的正确姿势

锁能覆盖所有受保护的资源

共享锁

### 总结

原子性的本质：操作的中间状态对外不可见。


## 05  一不小心死锁了，怎么办？

### 向现实世界要答案

### 没有免费的午餐

细粒度锁。使用细粒度锁可以提高并行度，是性能优化的一个重要手段。

使用细粒度锁是有代价的，这个代价就是可能会导致死锁。

**死锁：** 一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。


### 如何预防死锁

死锁条件：
  1. 互斥
  2. 占用且等待
  3. 不可抢占
  4. 循环等待
  
解决方法：

1. 破坏占用且等待条件
2. 破坏不可抢占条件
3. 破坏循环等待条件

### 总结

利用现实世界的模型来构思解决方案。

用细粒度锁来锁定多个资源时，要注意死锁问题。

识别出风险很重要。

评估一下操作成本，从中选择一个成本最低的方案。

## 06 用“等待-通知”机制优化循环等待

如果线程要求的条件不满足，则线程阻塞自己，进入等待状态；
当线程要求的条件满足后，通知等待的线程重新执行。

### 一个完整的等待-通知机制
首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；
当要求的条件满足时，通知等待的线程，重新获取互斥锁。

### 用synchronized实现等待-通知机制

等待队列：互斥队列= 1：1

notify() 只能保证在通知时间点，条件是满足的。执行时间点和通知的时间点基本上不会重合。

### 小试牛刀：一个更好地资源分配器

在等待-通知机制中，我们需要考虑以下四个因素：
1. 互斥锁
2. 线程要求的条件
3. 何时等待
4. 何时通知
   
尽量使用 notifyAll()

notify() 是会随机地通知等待队列中的一个线程，而notifyAll()会通知等待队列所有线程。


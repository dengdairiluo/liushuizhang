
# 1.你为什么要学并发编程
并发 = 分工 + 同步 + 互斥

**分工**：如何高效地拆解任务并分配给线程

**同步** ： 线程之间如何协作

**互斥**： 保证同一时刻只允许一个线程访问共享资源

# 2. 如何才能学好并发 编程

## 分工
## 同步
一个线程执行完了一个任务，如何通知执行后续任务的线程开工

当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行

管程是解决并发问题的万能钥匙

## 互斥（线程安全）
**互斥：** 同一时刻，只允许一个线程访问共享变量


## 并发编程结构

* 并发编程
  * 协作
    * 信号量
    * 管程 
      * Lock&Condition
      * synchronized
    * CountDownLatch
    * CyclicBarrier
    * Phaser
    * Exchanger
  * 互斥
    * 无锁
      * 不变模式
      * 线程本地存储
      * CAS
      * Copy-on-Write
      * 原子类
    * 互斥锁
      * synchronized
  * 分工
    * Exeutor与线程池
    * Fork/Join
    * Future
    * Guarded Suspension模式
    * BalKing模式
    * Thread-Per-Message模式
    * 生产者-消费者模式
    * Worker Thread模式
    * 两阶段终止模式

工程上的解决方案，一定要有理论基础

# 01 可见性、原子性和有序性问题：并发编程Bug的源头

## 并发程序幕后的故事

为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：
* CPU 增加了缓存，以均衡与内存的速度差异；
* 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异;
* 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

## 缓存导致的可见性问题

**可见性：** 一个线程对共享变量的修改，另外一个线程能够立刻看到。

## 线程切换带来的原子性问题

操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。

**原子性：** 我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性。

## 编译优化带来的有序性问题
有序性：程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，编译器调整了语句的顺序，但是不影响程序的最终结果。


只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。

#  Java内存模型：看Java如何解决可见性和有序性问题

## 什么是 Java 内存模型？

按需禁用缓存以及编译优化。

Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。

## 使用 volatile 的困惑

**volatile：**  对这个变量读写不能使用CPU缓存

## Happens-Before 规则

前面一个操作的结果对后续操作是可见的

1. 程序的顺序性规则
2. volatile变量规则
3. 传递性
4. 管程中锁的规则
5. 线程start() 规则
6. 线程join()规则
7. 被我们忽视的final

# 互斥锁（上）：解决原子性问题

## 原子性问题如何解决

原子性问题的源头是线程切换.

long 在32位机上并发问题

**互斥：** 同一时刻只有一个线程执行

### 简易锁模型

### 改进后的锁模型

### Java 语言提供的锁技术： synchronized

用synchronized 解决count += 1 的问题

# 互斥锁（下）：如何用一把锁保护多个资源

受保护资源和锁之间的合理的关联关系应该是N：1的关系


## 保护没有关联关系的多个资源

**细粒度锁：** 用不同的锁对受保护资源进行精细化管理，能够提升性能。

## 保护有关联关系的多个资源

## 使用锁的正确姿势

锁能覆盖所有受保护的资源

共享锁

## 总结

原子性的本质：操作的中间状态对外不可见。


# 05  一不小心死锁了，怎么办？

## 向现实世界要答案

## 没有免费的午餐

细粒度锁。使用细粒度锁可以提高并行度，是性能优化的一个重要手段。

使用细粒度锁是有代价的，这个代价就是可能会导致死锁。

**死锁：** 一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。


## 如何预防死锁

死锁条件：
  1. 互斥
  2. 占用且等待
  3. 不可抢占
  4. 循环等待
  
解决方法：

1. 破坏占用且等待条件
2. 破坏不可抢占条件
3. 破坏循环等待条件

## 总结

利用现实世界的模型来构思解决方案。

用细粒度锁来锁定多个资源时，要注意死锁问题。

识别出风险很重要。

评估一下操作成本，从中选择一个成本最低的方案。

# 06 用“等待-通知”机制优化循环等待

如果线程要求的条件不满足，则线程阻塞自己，进入等待状态；
当线程要求的条件满足后，通知等待的线程重新执行。

## 一个完整的等待-通知机制
首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；
当要求的条件满足时，通知等待的线程，重新获取互斥锁。

## 用synchronized实现等待-通知机制

等待队列：互斥队列= 1：1

notify() 只能保证在通知时间点，条件是满足的。执行时间点和通知的时间点基本上不会重合。

## 小试牛刀：一个更好地资源分配器

在等待-通知机制中，我们需要考虑以下四个因素：
1. 互斥锁
2. 线程要求的条件
3. 何时等待
4. 何时通知
   
尽量使用 notifyAll()

notify() 是会随机地通知等待队列中的一个线程，而notifyAll()会通知等待队列所有线程。


# 07 | 安全性、活跃性以及性能问题

## 安全性问题

**线程安全：** 本质上就是正确性，而正确性的含义就是**程序按照我们的期望的执行**

存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同事读写同一数据。

**数据竞争**

**竟态条件：** 程序的执行结果依赖线程执行的顺序

## 活跃性问题

除了死锁外，还有两种情况，分别是“活锁”和“饥饿”。

**活锁：** 有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况。

解决：谦让时，尝试等待一个随机的时间。

**饥饿：** 线程因无法访问所需资源而无法执行下去的情况。

解决方案：

1. 保证资源充足
2. 公平地分配资源
3. 避免持有锁的线程长时间执行
   
## 性能问题

Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。

建议：

1. 使用无所的算法与数据结构
2. 减少锁持有时间

性能指标：

* 吞吐量
* 延迟
* 并发量

# 8 | 管程：并发编程的万能钥匙

## 什么是管程

管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。

**管程：**管理共享变量以及对共享变量的操作过程，让他们支持并发。

## MESA 模型

并发编程领域两大核心问题：
1. 互斥
2. 同步

在管程模型里，共享变量和对共享变量的操作是被封装起来，只有一个入口，并且入口胖壁板还有一个入口等待队列。当多个线程试图进入管程内部，只允许一个线程进入，其他线程则在入口等待队列。

每个都对应有一个等待队列。

### wait() 的正确姿势
while循环里面调用wait()。这个是MESA管程特有的。

### notify() 何时可以使用

除非深思熟虑，否则尽量使用notifyAll()。

什么时候可以使用notify()呢？

1. 所有等待线程拥有相同的等待条件；
2. 所有等待线程被唤醒后，执行相同的动作。
3. 只需要唤醒一个线程。

重点是while里面的等待条件是完全相同的。



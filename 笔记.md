# 笔记

## Java并发编程实战

### 1.你为什么要学并发编程
并发 = 分工 + 同步 + 互斥

**分工**：如何高效地拆解任务并分配给线程

**同步** ： 线程之间如何协作

**互斥**： 保证同一时刻只允许一个线程访问共享资源

### 2. 如何才能学好并发 编程

#### 分工
#### 同步
一个线程执行完了一个任务，如何通知执行后续任务的线程开工

当某个条件不满足时，线程需要等待，当某个条件满足时，线程需要被唤醒执行

管程是解决并发问题的万能钥匙

#### 互斥（线程安全）
**互斥：** 同一时刻，只允许一个线程访问共享变量


#### 并发编程结构

* 并发编程
  * 协作
    * 信号量
    * 管程 
      * Lock&Condition
      * synchronized
    * CountDownLatch
    * CyclicBarrier
    * Phaser
    * Exchanger
  * 互斥
    * 无锁
      * 不变模式
      * 线程本地存储
      * CAS
      * Copy-on-Write
      * 原子类
    * 互斥锁
      * synchronized
  * 分工
    * Exeutor与线程池
    * Fork/Join
    * Future
    * Guarded Suspension模式
    * BalKing模式
    * Thread-Per-Message模式
    * 生产者-消费者模式
    * Worker Thread模式
    * 两阶段终止模式

工程上的解决方案，一定要有理论基础

### 01 可见性、原子性和有序性问题：并发编程Bug的源头

#### 并发程序幕后的故事

为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：
* CPU 增加了缓存，以均衡与内存的速度差异；
* 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异;
* 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

#### 缓存导致的可见性问题

**可见性：** 一个线程对共享变量的修改，另外一个线程能够立刻看到。

#### 线程切换带来的原子性问题

操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。

**原子性：** 我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性。

#### 编译优化带来的有序性问题
有序性：程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，编译器调整了语句的顺序，但是不影响程序的最终结果。


只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。

###  Java内存模型：看Java如何解决可见性和有序性问题

#### 什么是 Java 内存模型？

按需禁用缓存以及编译优化。

Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。

#### 使用 volatile 的困惑

**volatile：**  对这个变量读写不能使用CPU缓存

#### Happens-Before 规则

前面一个操作的结果对后续操作是可见的

1. 程序的顺序性规则
2. volatile变量规则
3. 传递性
4. 管程中锁的规则
5. 线程start() 规则
6. 线程join()规则
7. 被我们忽视的final




## MySQL实战45讲

### 0.开篇词 

从点到线，再到面，形成自己的MySQL知识网络

### 1.基础架构：一条SQL查询语句是如何执行的

**连接器** ：用户名密码验证，验证通过后获取权限

**查询缓存**
但是大多数情况下建议不使用查询缓存，因为弊大于利

**分析器**

**优化器**

**执行器**

### 2.日志系统：一条SQL更新语句是如何执行的

#### 重要日志模块： redo log ，bin log

redo log crash-safe
bin log 

**不同：**

* redo log InnoDB 特有； bin log MySQL Server层实现。
* redo log 是物理日志，记录在某个数据页上做了什么修改； binlog 是逻辑日志记录语句原始逻辑
* redo log 循环写，空间固定会用完；binlog 追加写入的。binlog文件写完一定大小后会切换到下一个
  
  **两阶段提交**

###  3 事务隔离：为什么你改了我还看不见？

#### 隔离性与隔离级别

ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）

SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）

* 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
* 读提交是指，一个事务提交之后，它做的变更就能被别的事务看到。
* 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
* 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 4 深入浅出索引（上）

索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。


####  索引的常见类型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。

##### 哈希表

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的值即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

哈希表这种结构适用于只有等值查询的场景

##### 有序数组
有序数组在等值查询和范围查询场景中的性能就都非常优秀

#### InnoDB 的索引模型

每一个索引在 InnoDB 里面对应一棵 B+ 树。

基于主键索引和普通索引的查询有什么区别？

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。


#### 索引维护

显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。

## 深入拆解Java虚拟机

### 0.为什么我们要学校java 虚拟机

*   基本原理
*   高效实现
*   代码优化
*   虚拟机黑科技

### 1.Java代码是怎么运行的

#### 为什么Java要在虚拟机里运行

java代码 编译成class文件加载到Java虚拟机中，加载后的Java会被存放于方法区中，实际运行会执行方法区内的代码。

* Java虚拟机
  * 线程共享
    * 方法区
    * 栈
  * 线程私有
    * PC寄存器
    * Java方法栈
    * 本地方法栈

在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java **虚拟机不要求栈帧在内存空间里连续分布**。

### 2. Java的基本类型

#### Java 虚拟机的 boolean 类型

在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。这个编码规则约束了 Java 字节码的具体实现。

#### Java 的基本类型

除了上面提到的 boolean 类型外，Java 的基本类型还包括整数类型 byte、short、char、int 和 long，以及浮点类型 float 和 double。
   
#### Java 基本类型的大小

也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。

#### 总结

其中，boolean 类型在 Java 虚拟机中被映射为整数类型：“true”被映射为 1，而“false”被映射为 0。Java 代码中的逻辑运算以及条件跳转，都是用整数相关的字节码来实现的。

除 boolean 类型之外，Java 还有另外 7 个基本类型。它们拥有不同的值域，但默认值在内存中均为 0。这些基本类型之中，浮点类型比较特殊。基于它的运算或比较，需要考虑 +0.0F、-0.0F 以及 NaN 的情况。

除 long 和 double 外，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的，但它们在堆中占用的大小确不同。在将 boolean、byte、char 以及 short 的值存入字段或者数组单元时，Java 虚拟机会进行掩码操作。在读取时，Java 虚拟机则会将其扩展为 int 类型。


### Java虚拟机是如何加载Java类的?

#### 加载

**加载：**是指查找字节流，并且据此创建类的过程。

**双亲委派模型**

#### 链接

链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

验证阶段的目的，在于确保被加载类能够满足 Java 虚拟机的约束条件。

准备阶段的目的，则是为被加载类的静态字段分配内存。Java 代码中对静态字段的具体初始化，则会在稍后的初始化阶段中进行。

解析阶段的目的，正是将这些符号引用解析成为实际引用。

#### 初始化

那么，类的初始化何时会被触发呢？JVM 规范枚举了下述多种触发情况：

当虚拟机启动时，初始化用户指定的主类；
当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
当遇到调用静态方法的指令时，初始化该静态方法所在的类；
当遇到访问静态字段的指令时，初始化该静态字段所在的类；
子类的初始化会触发父类的初始化；
如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
使用反射 API 对某个类进行反射调用时，初始化这个类；
当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

#### 总结与实践

今天我介绍了 Java 虚拟机将字节流转化为 Java 类的过程。这个过程可分为加载、链接以及初始化三大步骤。
加载是指查找字节流，并且据此创建类的过程。加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。
链接，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。链接还分验证、准备和解析三个阶段。其中，解析阶段为非必须的。
初始化，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。


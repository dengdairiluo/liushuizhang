# 设计模式

## 1. 引言

### 1.1 设计模式的基本要素

* 模式名称
* 问题
* 解决方案
* 效果

### 1.3 描述设计模式

* 模式名和分类
* 意图
* 别名
* 动机
* 适用性
* 结构
* 参与者
* 协作
* 效果
* 实现
* 代码示例
* 已知应用
* 相关模式

### 1.4 设计模式的编目

Abstract Factory(3.1): 提供一个创建一系列相关或依赖对象的接口，而无需指定它们具体的类。

Adapter(4.1): 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

Bridge(4.2): 将抽象部分与它的实现部分分离，是他们都可以独立地变化。

Builder(3.2): 将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。

Chain of Responsibiliry(5.1): 为解除请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，知道有一个队形处理它。

Command(5.2): 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。

Composite(4.3): 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得客户对单个对象和符合对象的使用具有一致性。

Decorator(4.4)： 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类方式更为灵活。

Facade(4.5): 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

Factory Method(3.3): 定义一个用于创建对象的接口，让子类决定将哪一个类实体化。Factory Method使一个类的实例化延迟到其子类。

Flyweight(4.6): 运用共享技术有效地支持大量细粒度的对象。

Interpreter(5.3): 给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。

Iterator(5.4): 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示。

Mediator(3.3): 定义一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

Memento(5.6): 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可讲该对象恢复到保存的状态。

Observer(5.7): 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。

Prototype(5.7): 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。

Proxy(4.7): 为其他对象提供一个代理以控制对这个对象的访问。

Singleton(3.5): 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

State(5.8): 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类。

Strategy(5.9): 定义一系列的算法，把他们一个个封装起来，并且使他们可互相替换。本模式使得算法的变化可独立于使用它的客户。

Template Method(5.10): 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

Visitor(5.11): 表示一个作用于某对象结构汇总的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素

### 1.5 组织编目

### 1.6设计模式怎样解决设计问题

#### 1.6.1 寻找合适的对象

面向对象设计最困难的部分是将系统分解成对象集合。以为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用等等。

#### 1.6.2 决定对象的粒度

#### 1.6.3 指定对象接口

#### 1.6.4 描述对象的实现

#### 1.6.5 运用复用机制

#### 1.6.6 关联运行时刻和编译时刻的结构

#### 1.6.7 设计应支持变化

一些导致重新设计的一般原因，以及解决这些问题的设计模式：

1. 通过显式地指定一个类来创建对象
    3.1，3.3，3.4
2. 对特殊操作的依赖
    5.1，5.2
3. 对硬件和软件平台的依赖
    3.1，4.2
4. 对对象表示或实现的依赖
    3.1，4.2，5.6，4.7
5. 算法依赖
    3.2，5.4，5.9，5.10，5.11
6. 紧耦合
    3.1，5.2，4.5，5.5，5.7，5.1
7. 通过生成子类来扩充功能
    4.2，5.1，4.3，4.4，5.7，5.9
8. 不能方便地对类进行修改
    4.1，4.4，5.11

### 1.7 怎样选择设计模式

### 1.8 怎样使用设计模式

## 2 实例研究：设计一个文档编辑器

## 3 创建型模式

### 3.1 ABSTRACT FACTORY (抽象工厂)——对象创建型模式

1. 意图

    提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

2. 别名

    Kit

3. 动机

4. 适用性
    * 一个系统要独立于它的产品的创建、组合和表示时。
    * 一个系统要由多个产品系列中的一个来配置时。
    * 当你要强调一系列相关的产品对象的设计以便进行联合使用时。
    * 当你提供一个产品类库，而只想显示它们的接口而不是实现时

5. 结构

6. 参与者

7. 协作

8. 效果
    1. 它分离了具体的类
    2. 它使得易于交换产品系列
    3. 它有利用产品的一致性
    4. 难以支持新种类的产品

9. 实现
    1. 将工厂作为单例
    2. 创建产品
    3. 定义可扩展的工厂

10. 代码实例

11. 已知应用

12. 相关模式
    Factory Method(3.3)，Singleton(3.5)

### 3.2 BUILDER(生成器)——对象创建型模式

1. 意图

    将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

2. 动机

3. 适用性
    * 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
    * 当构造过程必须允许被构造的对象有不同的表示时.

4. 结构

5. 参与者

6. 协作

7. 效果
    1. 它使你可以改变一个产品的内部表示
    2. 它将构造代码和表示代码分开
    3. 它使你可对构造过程进行更精细的控制

8. 实现
    1. 装配和构造接口
    2. 为什么产品没有抽象类
    3. 在Builder中缺省的方法为空

9. 代码实例

10. 已知应用

11. 相关模式
    
    Composite(4.3) 通常是用Builder生成的

### 3.3 FACTORY METHOD(工厂模式)

1. 意图
  
    定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。

2. 别名
   
   虚构造器

3. 动机

4. 适用性
    
    *当一个类不知道它所创建的对象的类的时候。
    *当一个类希望由它的子类来指定它所创建的对象的时候。
    *当类姜创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

5. 结构

6. 参与者

7. 协作
   
   Creator依赖于它的子类

8. 效果
   1. 为子类提供挂钩
   2. 连接平行的类层次

9. 实现
    1. 主要有两种不同情况
    2. 参数化工厂方法
    3. 特定语言的变化和问题
    4. 使用模板一避免创建子类
    5. 命名约定

10. 代码实例

11. 已知应用

12. 相关模式
    
    Abstact Factory(3.1)，Template Method(5.10)，Prototypes(3.4)

### 3.4 PROTOTYPE(原型)——对象创建型模式

1. 意图
    
    用原型实例指定创建对象的种类，并且通过这些原型创建新的对象

2. 动机

3. 适用性
    * 当要实例化的类实在运行时刻指定时，通过动态装载
    * 为了避免创建一个与产品类层次平行的工厂类层次时
    * 当一个类的实例只能有几个不同状态组合中的一种时。建立响应书目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。

4. 结构

5. 参与者

6. 协作
    
    客户请求一个原型克隆自身。

7. 效果
    1. 运行时刻增加和删除产品
    2. 改变值以指定新对象
    3. 改变结构以指定新对象
    4. 减少子类的构造
    5. 用类动态配置应用

8. 实现
    1. 使用一个原型管理器
    2. 实现克隆操作
    3. 初始化克隆对象

9. 代码示例

10. 已知应用

11. 相关模式
    
    Abstract Factory(3.1)，Composite(4.3), Decorator(4.4)

### 3.5 SINGLETON(单例)——对象创建型模式

1. 意图
    
    保证一个类仅有一个实例，并且提供一个访问它的全局访问点

2. 动机


3. 适用性

    * 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
    * 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

4. 结构

5. 参与者

6. 协作

    客户只能通过Singleton的Instance操作访问一个Singleton的实例

7. 效果

    1. 对唯一实例的受控访问
    2. 缩小名空间
    3. 允许对操作和表示的精化
    4. 允许可变数目的实例
    5. 比类操作更灵活

8. 实现

    1. 保证一个唯一的实例
    2. 创建Singleton类的子类

9. 代码示例

10. 已知应用

11. 相关模式

    很多模式可以用Singleton模式实现，参加Abstract Factory（3.1）、Builder（3.2）， 和Prototype（3.4）

### 3.6 创建型模式的讨论

## 4 结构型模式

### 4.1 ADAPTER（适配器）——类对象结构型模式

1. 意图

    将一个类的接口转换成客户希望的另一个接口转换成客户希望的另外一个接口。Adapter模式使得原本用于接口不兼容而不能一起工作的那些类可以一起工作。

2. 别名

    包装器 Wrapper

3. 动机

4. 适用性

    * 你想使用一个已经存在的类，而它的接口不符合你的需求
    * 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作
    * （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。

5. 接口

6. 参与者

7. 协作
    
    CLient在Adapter实例上调用一些操作。接着适配器调用Adaptee的操作实现这个请求。

8. 效果

    * 用一个具体的Adapter类对Adaptee和Target进行匹配。结果是当我们想要匹配一个类以及它所有的子类时，类Adapter将不能胜任工作。
    * 使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的一个子类。
    * 仅仅引入一个对象，并不需要额外的指针以间接得到Adaptee。
    * 允许一个Adapter与多个Adaptee——即Adaptee本身以及它的所有子类（如果有子类的话）——同时工作。Adapter也可以一次给所有的Adaptee添加功能。
    * 使得重定义Adaptee的行为比较困难。这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。
    
    其他因素：
    
    1. Adapter的匹配程度
    2. 可插入的Adapter
    3. 使用双向适配器提供透明操作

9. 实现

10. 代码实例

11. 已知应用

12. 相关模式
    
    Bridge（4.2），Decorator（4.4）， Prox（4.7）

### 4.2 BRIDGE(桥接)——对象结构型模式

1. 意图

    将抽象部分与它的实现部分分离，使它们都可以独立地变化。

2. 别名

    Handle/Body

3. 动机

    1. 扩展Window抽象使之适用于不同种类的窗口或新的系统平台很不方便。
    2. 继承机制使得客户代码与平台相关。

4. 适用性

    * 你不希望在抽象和他的实现部分之间有一个固定的保定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。
    * 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。
    * （C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。
    * 正如在意图一节的第一个类图中所示的那样，有许多类要生成。这样一种类层次结构说明你必须将一个对象分成两个部分。Rumbaugh 称这种类层次结构为“嵌套的普化”。
    * 你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类，在这个类多个对象可以共享同一个字符串表示（StringRep）。

5. 结构

6. 参与者

7. 协作

8. 效果

    1. 分离接口及其实现部分 
    2. 提高可扩充性
    3. 实现细节对客户透明

9. 实现

    1. 仅有一个Implementor
    2. 创建正确的Implementor对象
    3. 共享Implementor对象
    4. 采用多重继承机制

10. 代码示例

11. 已知应用

12. 相关模式


### 4.3 COMPOSITE(组合)——对象结构型模式

1. 意图

    将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

2. 动机

3. 适用性

    * 你想表示对象的部分-整体层次结构
    * 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

4. 结构

5. 参与者

6. 协作

    * 用户使用Component类接口与组合结构中的对象进行交互。如果接收者是一个叶节点，则直接处理请求。如果是Composite，他通常将请求发给他的子部件，在转发请求之前与/或之后可能执行一些辅助操作。

7. 效果

    * 定义了包含基本对象和组合对象的类层次结构
    * 简化客户代码
    * 使得更容易增加新类型的组件
    * 使你的设计变得更加一般化

8. 实现 

    1. 显式的父部件引用
    2. 共享组件
    3. 最大化Component接口
    4. 声明管理子部件的操作
    5. Component是否应该实现一个Component列表
    6. 子部件排序
    7. 使用高速缓冲存贮改善性能
    8. 应该由谁删除Component
    9. 存贮组件最好用哪一种数据结构

9. 代码实例

10. 已知应用 

11. 相关模式

### 4.4 DECORATOR(装饰)——对象结构型模式

1. 意图

    动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。

2. 别名

    包装器Wrapper

3. 动机

4. 适用性

    * 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
    * 处理那些可以撤销的职责。
    * 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

5. 结构

6. 参与者

7. 协作

8. 效果

    1. 比静态继承更灵活
    2. 避免在层次结构高层的类有太多的特征
    3. Decorator与它的Commponent不一样
    4. 有许多小对象

9. 实现

    1. 接口的一致性
    2. 省略抽象的Decorator类
    3. 保持Component类的简单性
    4. 改变对象外裤与改变对象内核

10. 代码示例

11. 已知应用

### 4.5 FACADE（外观）——对象结构型模式

1. 意图

    为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

2. 动机
    
    将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小。
    达到该目的的途径之一就是引入一个外观（facade）对象，它为子系统中较一般的设施提供一个单一而简单的界面。

3. 适用性

    * 当你要为一个复杂的子系统提供一个简单的接口时。子系统往往因为不断演化而变得越来越复杂。
    大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以约过Facade层。
    * 客户程序与抽象类的实现部分之间存在着很大的依赖性。
    * 当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。

4. 结构

5. 参与者

6. 协作

    * 客户程序通过发送请求给Facade的方式与子系统通讯，Facade将这些消息转发给适当的子系统对象了尽管是子系统中的有关对象在做实际工作，但Facade模式本身也必须将它的接口转换成子系统的接口。
    * 使用Facade的客户程序不需要直接访问子系统对象。

7. 效果

    1. 它对客户屏蔽子系统组件。
    2. 他实现了子系统与客户之间的松耦合关系，儿子系统内部的功能往往是紧耦合的。
    3. 如果应用需要，它并不限制他们使用子系统类。

8. 实现

9. 代码示例

10. 已知应用

11. 相关模式

### 4.6 FlYAWEIGHT（享元）—— 对象结构模式

1. 意图

    运用共享技术有效地支持大量细粒度的对象

2. 动机

    有些应用程序得益于在其整个设计过程中采用对象技术，但简单化的实现代价极大。

3. 适用性

    * 一个应用程序是用来大量的对象。
    * 完全由于使用大量的对象，造成很大的存储开销。
    * 如果删除对象的外部状态，那么可以用相对较少的共享对象去带很多组对象
    * 应用程序不依赖对象标识。

4. 结构

5. 参与者

6. 协作

    * flyweight执行时所需的状态必定是内部的或外部的。内部状态存储于ConcreteFlyweight对象之中；而外部对象则由Client对象存储或计算。当用户调用flyweight对象时，讲稿状态传递给它。
    * 用户不应直接对CloncreteFlyweight类进行实例化，而只能从FlyweightFactory对象得到ConcreteFlyweight对象，这可以保证对它们适当地进行共享

7. 效果

    使用Flyweight模式时，传输、查找和/或计算外部状态都会产生运行时的开销，尤其当Flyweight原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。

8. 实现

    1. 删除外部状态
    2. 管理共享对象

9. 代码示例

10. 已知应用

11. 相关模式

### 4.7 PROXY（代理）——对象结构型模式

1. 意图

    为其他对象提供一种代理以控制对这个对象的访问

2. 别名

    Surrogate

3. 动机

    对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个歌对象时才对它进行创建和初始化。

4. 适用性

    1. 远程代理
    2. 徐代理
    3. 保护代理
    4. 智能指引

    * 当第一次引用一个持久对象时，将他装入内存。
    * 在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。

5. 结构

6. 参与者

7. 协作

    代理根据其种类，在适当地时候向RealSubject转发请求。

8. 效果

    Proxy模式在访问对象时引入一定程度的间接性。根据代理的类型，附件的间接性有多种用途：
    1. Remote Proxy 可以隐藏一个对象存在于不同地址空间的事实。
    2. Virtual Proxy，可以进行最优化，例如根据要求创建对象
    3. Protecttion Proxies 和 Smart Reference都允许在访问一个对象时有一些附加的内务处理。

9. 实现

10. 代码示例

11. 已知应用

12. 相关模式


### 4.8 结构型模式的讨论

## 5. 行为模式

### 5.1 CHAIN OF RESPONSIBILITY（职责连）——对象行为型模式

1. 意图

    使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，只要有一个对啊ing处理它为止。

2. 动机

    考虑一个图形用户界面中的上下文有关的帮助机制。

3. 适用性

    * 有多个的对象可以处理一个请求，那个对象处理请求运行时刻自动决定。
    * 你想在不明确确定指定接收者的情况下，向多个对象中的一个提交一个请求。
    * 可处理一个请求的对象集合应被动态指定。

4. 结构

5. 参与者

6. 协作

    * 当客户提交一个请求时，请求沿链传递直至有一个ConcreteHandler对象负责处理它。

7. 效果

    1. 降低耦合度
    2. 增强了给对象指派职责（responsibility）的灵活性
    3. 不保证被接受

8. 实现

    1. 实现后继者链
        1. 定义新的链接。
        2. 使用已有的链接。
    2. 连接后继者
    3. 表示请求
    4. 在Smalltalk中自动转发

9. 代码实例

10. 已知应用

11. 相关模式

### 5.2 COMMAND（命令）——对象行为型模式

1. 意图

    将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销操作。

2. 别名

    动作（action），事务（Transaction）

3. 动机

    有时必须向某对象提交请求，但并不知道关于被请求的操作或者请求的接受者的任何信息。

4. 适用性

    * 像上面讨论的那样，抽象出待执行的动作以参数化某对象。你可用过程语言中的回调函数表达多种参数化的机制。 
    * 在不同的时刻指定、排列和执行请求。
    * 支持取消操作
    * 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。
    * 用构建在原语操作上的高层操作构造一个系统。

5. 结构

6. 参与者

7. 协作

    * CLient创建一个ConcreteCommand对象并指定它的receiver对象
    * 某Invoker对象存储该ConcreteCommand对象
    * 该Invoker通过调用Command对象的Execute操作来提交一个请求。
    * ConcreteComand对象调用它的Receiver的一些操作以执行该请求。


8. 效果

    1. Command模式将调用操作的对象与知道如何实现该操作的对象解耦。
    2. Command是头等的对象。他们可像其他的对象一样被操纵和扩展。
    3. 你可将多个命令装配成一个复合命令。
    4. 增加新的Command很容易，因为者无需改变已有的类。

9. 实现

    1. 一个命令对象应达到何种智能程度
    2. 支持取消(undo)和重做(redo)
    3. 避免取消操作过程中的错误积累
    4. 使用C++模板

10. 代码示例

11. 已知应用

### 5.3 INTERPRETER(解释器)——类行为模式

1. 意图

    给定一个语言，定义它的文法的一种表示，并且定义一个解释器，
    这个解释器使用该表示来解释语言中的句子。

2. 动机

    如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表示为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

3. 适用性

    * 该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。
    * 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一个形式。

4. 结构

5. 参与者

6. 协作

    * Client构建（或被指定）一个句子，它是NonterminalExpression和TerminalExpression的实例的一个抽象语法树，然后初始化上下文并调用解释操作
    * 每一非终结符表达式节点定义相应子表达式的解释操作。而各终结符表达式的解释操作构成了递归的基础。
    * 每一节点的解释操作用上下文来存储和访问解释器的状态。

7. 效果

    1. 易于改变和扩展文法
    2. 也易于实现文法
    3. 复杂的文法难以维护
    4. 增加了新的解释器表达式的方式

8. 实现

    1. 创建抽象语法树
    2. 定义解释操作
    3. 与FlyWeight模式共享终结符

9. 代码示例

10. 已知应用

11. 相关模式

### 5.4 ITERATOR(迭代器)——对象行为型模式

1. 意图

    提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露对象的内部表示。

2. 别名

    游标（Cursor）

3. 动机

    一个聚合对象，如列表（list），应该提供一种方法来让别人可以访问它的元素，而又不需暴露它的内部结构，此外，针对不同的需要，可能要以不同的方式遍历这个列表。但是即使可以预见到所需的那些办理操作，你可能也不希望列表的接口中充斥着各种不同遍历的操作。有事还可能需要在同一个列表上同时进行多个遍历。

4. 适用性

    * 访问一个聚合对象的内容而无需暴露他的内部表示。
    * 支持对聚合对象的多种遍历
    * 为遍历不同的聚合结构提供一个统一的接口

5. 结构

6. 参与者

7. 协作

8. 效果

    1. 它支持以不同的方式遍历一个聚合
    2. 迭代器简化了聚合的接口
    3. 在同一个聚合上可以有多个遍历

9. 实现

    1. 谁控制该迭代
    2. 谁定义遍历算法
    3. 迭代器健壮程度如何
    4. 附加的大额带起操作
    5. 在C++中使用多态的迭代器
    6. 迭代器可有特权访问
    7. 用于复合对象的迭代器
    8。 空迭代器

10. 代码示例

11. 已知应用

12. 相关模式

### 5.5 MEDIATOR（中介者）——对象行为型模式

1. 意图

    用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

2. 动机

    面向对象设计鼓励将行为分部到各个对象中。这种分部可能会导致对象间有许多连接。在最坏的情况下，每一个对象都知道其他所有对象。

3. 适用性

    * 一组对象以定义良好但是复杂的方式进行通信。产生的相互依赖关系结构混乱且难以理解。
    * 一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象。
    * 想定制一个分部在多个类中的行为，而又不想生成太多的子类

4. 结构

5. 参与者

6. 协作

7. 效果

    1. 减少子类生成
    2. 它将各colleague解耦
    3. 他简化了对象协议
    4. 它对对象如何协作进行了抽象
    5. 它使控制集中化

8. 实现

    1. 忽略抽象的Mediator类
    2. Colleague——Mediator类通信

9. 代码示例

10. 已知应用

11. 相关模式

### 5.6 MEMENTO(备忘录)——对象行为型模式

1. 意图

    在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
    这样以后就可将该对象恢复到原先保存的状态。

2. 别名

    Token

3. 动机

    有时有必要记录一个对象的内部状态。为了允许用户取消不确定的操作或从错误中恢复过来，
    需要实现检查点和取消机制，而要实现这些机制，你必须事先将状态信息保存在某处，这样才能将对象恢复到它们先前的状态。但是对象通常封装了其部分或所有的状态信息，是的其状态不能被其他对象访问，也就不可能在该对象之外保存期状态。而暴露其内部状态又将违反封装的原则，可能有损应用的 可靠性和可扩展性。

4. 适用性

    * 必须保存一个对象在某一时刻的（部分）状态，这样以后需要时他才能恢复到先前的状态。
    * 如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。

5. 结构

6. 参与者

7. 协作

    * 管理器像原发器请求一个备忘录，保留一段时间后，将其返回给原发器，入下面的交互图所示。有时管理者不会将备忘录返回给原发器，因为原发器可能根本不需要退给先前的状态。
    * 备忘录是被动的。只有创建备忘录的原发器会对它的状态进行赋值和检索。

8. 效果

    1. 保持封装边界
    2. 它简化了原发器
    3. 使用备忘录可能代价很高
    4. 定义宽接口和窄接口
    5. 维护备忘录的潜在代价

9. 实现

    1. 语言支持
    2. 存储增量式改变

10. 代码示例

11. 已知应用

12. 相关模式

### 5.7 OBSERVER（观察者）——对象行为型模式

1. 意图

    定义对象间的一种一对多的依赖关系，

2. 别名

    依赖（Dependents），发布-订阅（Publish-Subscribe）

3. 动机

   将一个系统分割成一系列相互协作的类有一个常见的副作用：需要维护相关对象间的一致性。我们不希望为了维持一致性。我们不希望为了维持一致性而使各类紧密耦合，因为这样降低了它们的可重用性。

4. 适当性

    在以下任一情况下可以使用观察者模式：
    
    * 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
    * 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
    * 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的。

5. 结构

6. 参与者

7. 协作

    * 当ConcreteSubject发生任何可能导致其观察者与其本身状态不一致的改变时，它将通知他的各个观察者。
    * 在得到一个具体目标的改变通知后，ConcreteObserver对象可向目标对象查询信息。ConcreObserver对象可向目标对象查询信息。ConcreteObserver使用这些信息以使它的状态与目标对象的状态一致。

8. 效果

    1. 目标和观察者间的抽象耦合
    2. 支持广播通信
    3. 意外的更新

9. 实现

    1. 创建目标到其观察者之间的映射
    2. 观察多个目标
    3. 谁触发更新
    4. 对已删除目标的悬挂引用
    5. 在发出同之前确保目标的状态自身是一致的
    6. 避免特定于贯彻的更新协议——推/拉模型
    7. 显式地指定感兴趣的改变
    8. 封装复杂的更新语义
    9. 结合目标类和观察者类

10. 代码示例

11. 已知应用

12. 相关模式

### 5.8 STATE(状态)——对象行为型模式

1. 意图

    允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

2. 别名

    状态对象（Objects for States）

3. 动机

    考虑一个表示网络连接的类TCPConnection。一个TCPConnection对象的状态处于若干不同状态之一：连接已建立（Established）、正在监听（Listening）、连接已关闭（Closed）。
    当一个TCPConnection对象收到其他对象的请求时，它根据自身的当前状态作出不同的反应。
    例如，一个Open请求的结果依赖于该连接是处于连接已关闭状态还是连接已建立状态。State模式描述了TCPConnection如何在每一种状态下表现出不同的行为。

4. 适用性

    * 一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。
    * 一个操作中汉语庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一条件分支放入一个独立的勒种。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。

5. 结构

6. 参与者

7. 协作

    * context将与状态相关的请求委托给当前的ConcreteState对象处理。
    * Context可将自身作为一个参数传递给处理该请求的状态对象。
    这使得状态对象在必要时可访问Context。
    * Context是客户使用的主要接口。客户可用状态对象来配置一个Context，一单一个Context配置完毕，它的客户不再需要直接与状态对象打交道。
    * Context或ConcreteState子类都可决定那个状态时另外哪一个的后继者，以及是在何种条件下进行状态转换。

8. 协作

    State模式有下面一些效果：
    1. 它将于特定状态相关的行为局部化，并且将不同状态的行为分割开来。
    2. 它使得状态转换显式化。
    3， State对象可被共享。

9. 实现

    实现State模式有多方面的考虑：
    1. 谁定义状态转换
    2. 基于表的另一种方法
    3. 创建和销毁State对象
    4. 使用动态继承

10. 代码示例

11. 已知应用

12. 相关模式

### 5.9 STRATEGY（策略）——对象行为型模式

1. 意图

    定义一系列的算法，把它们一个个封装气力啊，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化

2. 别名

    政策（Policy）

3. 动机

    有许多算法可对一个正文流进行分行。将这些算法硬编进使用它们的类中是不可取的。我们可以定义一些类来封装不同的换行算法，从而避免这些问题。一个以这种方法封装的算法成为一个策略（Strategy）

4. 适用性

    * 许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。
    * 需要使用一个算法的不同变体。
    * 算法使用客户不应该知道的数据。
    * 一个类定义了多种行为，并且这些行为

5. 结构

6. 参与者

7. 协作

    * Strategy和Context相互作用以实现选定的算法。当算法被调用时，Context可以将该算法所需要的所有数据都传递给该Strategy。或者，Context可以将自身作为一个参数传递给Strategy操作。这就让Strategy在需要时可以回调Context。
    * Context将它的客户的请求转发给它的Strategy。客户通常创建并传递一个ConcreteStrategy对象给该Context；这样，客户仅与Context交互。通常有一系列的ConcreteaStrategy类可供客户从中选择。

8. 效果

    1. 相关算法系列。
    2. 一个替代继承的方法。
    3. 消除了一些条件语句
    4. 实现的选择
    5. 客户不需了解不同的Strategy
    6. Strategy和Context之间的通信开销
    7. 增加了对象的数目

9. 实现

    1. 定义Strategy和Context接口
    2. 将Strategy作为模板参数
    3. 使Strategy对象成为可选的

10. 代码示例

11. 已知应用

12. 相关模式

### 5.10 TEMPLATE METHOD (模板方法)——类行为型模式

1. 意图

     定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Tempalte Method使得子类可以不改变一个算法的接口即可重定义该算法的某些特定步骤。

2. 动机

    考虑一个提供Application和Document类的应用框架。Application类复杂打开一个已有的以外部形式存储的文档，如一个文件。一旦一个文档中的信息从该文件中读出后，它就由一个Document对象表示。

3. 适用性

    * 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
    * 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。
    * 控制子类扩展

4. 结构

5. 参与者

6. 协作

    * ConcreteClass靠AbstractClass来实现算法中不变的步骤。

7. 效果

    * 具体的操作
    * 具体的AbstractClass的操作
    * 原语操作
    * Factory Method
    * 钩子操作

8. 实现

    1. 使用C++访问控制
    2. 尽量减少原语操作
    3. 命名约定

9. 代码示例

10. 已知应用

11. 相关模式

### 5.11 VISITOR（访问者）——对象行为型模式

1. 意图

    表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作

2. 动机

    考虑一个编译器，它将源程序表示为一个抽象语法树。该编译器需要在抽象语法树上实施某些操作以进行“静态语义“分析，例如检查是否所有的变量都已经被定义了。它也需要生成代码。因此它可能要定义许多操作已进行类型检查、代码优化、流程分析，检查变量是否在使用前被赋初值，等等。此外，还可使用抽象语法树进行优美格式打印、程序重构、code instrumentation以及对程序进行多种度量。

3. 适用性

    * 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作。
    * 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而你想避免让这些操作”污染“这些对象的类。Visitor使得你可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用Visitor使得你可以将相关的操作集中起来定义在一个类中。
    * 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有范文这的接口，这可能需要很大的代价。如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。

4. 结构

5. 参与者

6. 协作

    * 一个使用Visitor模式的客户必须创建一个ConcreteVisitor对象，然后便利该对象结构，并用该访问者访问每一个元素。
    * 当一个元素被访问时，他调用对应于它的类的Visitor操作。如果必要，该元素将自身作为这个操作的一个参数y边该访问者访问它的状态

7. 效果

    1. 访问者模式使得易于增加新的操作
    2. 访问者集中相关的操作而分离无关的操作
    3. 增加新的ConcreteElement类很困难
    4. 通过类层次进行访问
    5. 累积状态
    6. 破坏风筝

8. 实现

    1.双分派
    2. 谁负责遍历对象结构

9. 代码示例

10. 已知应用

11. 相关模式

### 5.12 行为模式的讨论

1. 封装变化

2. 对象作为参数

3. 通信应该被封装还是被分布

4. 对发送者和接收者解耦

5. 总结

## 6. 结论

1. 设计模式将带来什么

2. 一套通用的设计词汇

3. 书写文档和学习的辅助手段

4. 现有方法的一种补充

5. 重构的目标

6. 本书简史

7. 模式界

8. Alexander 模式

9. 软件中的模式

10. 邀请参与

11. 临别感想